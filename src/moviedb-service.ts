export interface TmdbMovie {
  adult: boolean;
  backdrop_path: string;
  genre_ids: number[];
  id: number;
  original_language: string;
  original_title: string;
  overview: string;
  popularity: number;
  poster_path: string;
  release_date: string;
  title: string;
  video: boolean;
  vote_average: number;
  vote_count: number;
}

/**
 * This response type is generated by curl:ing the response and pasting it into http://json2ts.com/.
 *
 * It's the same response format for searching, popular- & top rated movies.
 */
export interface TmdbResponse {
  page: number;
  results: TmdbMovie[];
  total_pages: number;
  total_results: number;
}

export type TmdbSearch = ({term, limit}: {term: string, limit: number}) => Promise<TmdbMovie[]>
export type TmdbCallback = () => Promise<TmdbMovie[]>;

export interface TmdbApiClient {
  search: TmdbSearch;
  popular: TmdbCallback;
  topRated: TmdbCallback;
}

export const sortMoviesByProp =
  (prop: keyof TmdbMovie) =>
    (a: TmdbMovie, b: TmdbMovie) => {
      if (a[prop] < b[prop]) {
        return -1;
      } else if (a[prop] > b[prop]) {
        return 1;
      }
      return 0;
    };

export class BadInput extends Error {
  constructor(message: string) {
    super(message);
  }

  public custom = 'custom';
}

/**
 * Some kind of Gateway or facade pattern.
 */
export class TmdbService {
  /**
   * Arbitrarily chosen
   */
  public static maxSearchResults = 400;

  constructor(private readonly apiClient: TmdbApiClient) {
  }

  /**
   * Executes a HTTP request and leaves the error handling to the caller.
   *
   * This function is not wrapping the result or error in any way, so you're exposed directly to the inner logic of
   * Axios, the HTTP client.
   */
  async search(
    {term, limit}: {term: string | undefined, limit: string | number | undefined}
  ): Promise<TmdbMovie[]> {
    if (typeof term !== 'string' || term.length < 1 || term.length > 100) {
      throw new BadInput('Missing or invalid search term. Try /search/dune');
    }

    if (typeof limit === 'string') {
      limit = parseInt(limit);
      if (isNaN(limit)) {
        throw new BadInput('Bad format of the limit query parameter');
      }
    } else if (typeof limit !== 'number') {
      limit = TmdbService.maxSearchResults;
    }

    if (limit < 1 || limit > TmdbService.maxSearchResults) {
      throw new BadInput(`Limit must be between than 1 and ${TmdbService.maxSearchResults}`);
    }

    return this.apiClient.search({term, limit});
  }

  async topRatedPopular(): Promise<TmdbMovie[]> {
    const result: TmdbMovie[] = await Promise.all([this.apiClient.popular(), this.apiClient.topRated()])
      .then(([popular, topRated]) => popular.slice(0, 10).concat(topRated.slice(0, 10)));

    return result.sort(sortMoviesByProp('title'));
  }
}
