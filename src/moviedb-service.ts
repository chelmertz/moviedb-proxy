// TODO decouple emitting the result from the fetching part, so that we can focus on testing the combination/HTTP
// failure modes

export interface TmdbMovie {
  adult: boolean;
  backdrop_path: string;
  genre_ids: number[];
  id: number;
  original_language: string;
  original_title: string;
  overview: string;
  popularity: number;
  poster_path: string;
  release_date: string;
  title: string;
  video: boolean;
  vote_average: number;
  vote_count: number;
}

/**
 * This response type is generated by curl:ing the response and pasting it into http://json2ts.com/.
 *
 * It's the same response format for searching, popular- & top rated movies.
 */
export interface TmdbResponse {
  page: number;
  results: TmdbMovie[];
  total_pages: number;
  total_results: number;
}

export interface TmdbApiClient {
  search: ({term, limit}: {term: string, limit: number}) => Promise<TmdbMovie[]>;
  popular: () => Promise<TmdbMovie[]>;
  topRated: () => Promise<TmdbMovie[]>;
}

export const sortMoviesByProp =
  (prop: keyof TmdbMovie) =>
    (a: TmdbMovie, b: TmdbMovie) => {
      if (a[prop] < b[prop]) {
        return -1;
      } else if (a[prop] > b[prop]) {
        return 1;
      }
      return 0;
    };

/**
 * Some kind of Gateway or facade pattern.
 */
export class TmdbService {
  /**
   * Arbitrarily chosen
   */
  public static maxSearchResults = 400;

  constructor(private readonly apiClient: TmdbApiClient) {
  }

  /**
   * Executes a HTTP request and leaves the error handling to the caller.
   *
   * This function is not wrapping the result or error in any way, so you're exposed directly to the inner logic of
   * Axios, the HTTP client.
   */
  // TODO consider using a sum type as return value, in favor of runtime exceptions
  async search({term, limit = TmdbService.maxSearchResults}: {term: string, limit: number}): Promise<TmdbMovie[]> {
    return this.apiClient.search({term, limit});
  }

  // TODO Let's decide that users of our proxy service are fine with just getting popular or top rated movies,
  // just in case one of the requests failed.
  async topRatedPopular(): Promise<TmdbMovie[]> {
    const result: TmdbMovie[] = await Promise.all([this.apiClient.popular(), this.apiClient.topRated()])
      .then(([popular, topRated]) => popular.slice(0, 10).concat(topRated.slice(0, 10)));

    return result.sort(sortMoviesByProp('title'));
  }
}
